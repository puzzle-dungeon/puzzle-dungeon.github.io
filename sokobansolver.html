<!DOCTYPE html>
<html lang="en">
<head>
<base href="https://puzzle-dungeon.github.io/">
<link rel="canonical" href="https://puzzle-dungeon.github.io/sokobansolver.html">
<meta charset="UTF-8">
<meta name="description" content="Puzzle Dungeon is a cell-based puzzle game.
	Page: Sokobansolver">
<meta name="keywords" content="puzzles, puzzle game, dungeon,
	atomix, stoneage, chip challenge,
	sokoban, sokoban solver, sokoban generator,
	atomix puzzle,
	barrel puzzle,
	color puzzle,
	fifteen puzzle,
	gate puzzle,
	hero puzzle,
	lock puzzle,
	memory puzzle,
	minotaur puzzle,
	mirror puzzle,
	portal puzzle,
	rotatepic puzzle,
	stoneage puzzle,
	switchbox puzzle,
	puzzle dungeon">
<link rel="icon" type="image/png" href="images/ancient2/portal.png">
<title>Puzzle Dungeon - Sokobansolver</title>
<style>
html {
	height: 100%;
}
body {
	margin: 0px;
	width: 100%;
	height: 100%;
}

div {
	margin: 0px;
	padding: 0px;
}

#body {
	display: grid;
	grid-gap: 0px;
	grid-template-columns: 256px;
	grid-template-rows: 128px 128px;
	grid-template-areas:
		"logo    header"
		"logo    content"
		"sidebar content";
	height: 100%;
}

#logo {
	grid-area: logo;
}

#sidebar {
	grid-area: sidebar;
	background: url("sidebar-bg.jpg") repeat #dcb;
	color: navy;
	padding: 10px;
	text-align: center;
}

#header {
	grid-area: header;
	background: url("header-bg.jpg") repeat #234;
}

#content {
	grid-area: content;
	background: url("content-bg.jpg") repeat #567;
	padding: 10px;
	color: #f0f0f0;
}

#categories {
	margin: 0px 0px;
	display: flex;
	flex-wrap: wrap;
	justify-content: space-evenly;
	align-items: center;
	height: 100%;
}

button {
	white-space: nowrap;
	font-family: Arial, sans-serif;
}

a {
	text-decoration: none;
}

.category {
	margin: auto 7px;
	border: 1px solid black;
	border-radius: 16px;
	width: 160px;
	height: 52px;
	background: #4e5f6d;
	color: #e0e0e0;
	font-size: 22px;
	font-weight: bold;
	text-decoration: none;
}

.current-category {
	background: #46b482;
}

.category:hover {
	background: #4682b4;
	color: white;
	transform: translateY(-3px) scale(110%);
}

.current-category:hover {
	background: #46b482;
}

.page {
	display: block;
	margin: 3px auto;
	border: 1px solid rgba(32, 32, 32, 0.2);
	border-radius: 3px;
	width: 220px;
	height: 30px;
	overflow: hidden;
	background: transparent;
	backdrop-filter: brightness(90%);
	color: #111;
	font-size: 18px;
	font-weight: normal;
}

.current-page {
	backdrop-filter: hue-rotate(80deg) brightness(90%);
}

.page:hover {
	transform: scale(105%);
	backdrop-filter: hue-rotate(110deg) brightness(90%);
	color: #000;
}

.current-page:hover {
	backdrop-filter: hue-rotate(80deg) brightness(90%);
}

#sidebar hr {
	border: 0.5px solid rgba(32, 32, 32, 0.2);
	width: 200px;
	margin: 12px auto;
}

#content h1 {
	margin: -10px;
	margin-bottom: 0px;
	padding: 10px;
	backdrop-filter: brightness(90%);
	text-align: center;
}

#content > code {
	display: block;
	padding: 10px;
	backdrop-filter: contrast(60%);
}

#content table {
	color: inherit;
	padding: 10px;
	border: solid 1px #234;
}

#content a {
	color: rgb(255, 255, 128);
	text-decoration: none;
}

#content a:visited {
	color: rgb(100, 200, 40);
}

#content a:active {
	color: rgb(220, 110, 110);
}

.puzzle-entry {
	display: flex;
	justify-content: space-evenly;
	align-items: center;
	border-bottom: 1px solid rgba(16, 16, 16, 0.4);
}

.puzzle-info {
	flex: 1;
}

.puzzle-info p:not(.goal) {
	text-align: justify;
	text-justify: auto;
	padding-right: 10px;
}

.puzzle-screenshot {
	width: 256px;
}

.puzzle-screenshot img {
	width: 256px;
	object-fit: scale-down;
	padding: 6px 0px;
}

p.goal {
	 font-style: italic;
}

p.goal:before {
	 content: "Goal: ";
}

.theme-images {
	width: 0;
	min-width: 100%;
	overflow-x: auto;
}

#img-table {
	width: 100%;
	padding: 10px;
	table-layout: fixed;
}

#img-table tr > * {
	margin: 0px;
	padding: 1px;
	white-space: nowrap;
	text-align: center;
	vertical-align: middle;
}

#img-table th {
	font: 14px Arial, sans-serif;
	overflow: hidden;
}

#img-table tr:first-child > th:not(:first-child) {
	font-size: 12px;
}

#img-table .zoom,
#img-table tr > th:not(:first-child) {
	height: 32px;
}

#img-table th:first-child {
	width: 70px;
}

.img-table-full tr > th:first-child {
	height: 64px;
}

.img-table-half tr > th:first-child {
	height: 28px;
}

.img-table-full tr > th:not(:first-child) {
	width: 64px;
}

.img-table-half tr > th:not(:first-child) {
	width: 28px;
}

.img-table-half tr > td {
	width: 28px;
	height: 28px;
}

.img-table-full tr > td {
	width: 64px;
	height: 64px;
}

.img-table-half img {
	width: 28px;
	height: 28px;
}

.img-table-full img {
	width: 64px;
	height: 64px;
}

.img-table-full img[title="char"], .img-table-full img[title="enemy"] {
	width: 50px;
	height: 50px;
}

#img-table .zoom {
	text-align: left;
}

.home-medias {
	width: 100%;
	display: flex;
	flex-wrap: nowrap;
	justify-content: center;
	align-items: center;
}

.all-medias {
	width: 100%;
	display: flex;
	flex-wrap: wrap;
	justify-content: space-evenly;
	align-items: flex-start;
}

.home-medias .media {
	margin: 4px;
	max-width: 20%;
}

.all-medias .media {
	margin: 4px;
	flex-basis: 24%;
	max-width: 24%;
}

.media img, .media video {
	width: 100%;
	object-fit: scale-down;
}

.media-title {
	margin: 2px;
	height: 20px;
	text-align: center;
	white-space: nowrap;
	overflow: hidden;
	color: #ffffa0;
}

.media-container {
	padding: 1px;
	width: 100%;
	text-align: center;
}

p:has(.media-container) {
	width: 100%;
	text-align: center;
}

.media {
	object-fit: scale-down;
	margin: 0px auto;
}

.media-property {
	display: inline;
	float: right;
	padding: 0px 10px 0px 30px;
}

pre.highlight  {
	width: 100%;
	color: #e0e0e0;
	background-color: #6080c0;
	font-size: 10pt;
	font-family: 'Courier New', monospace;
	white-space: pre;
	overflow: auto;
}
.highlight.num { color: #60f0f0; }
.highlight.sng { color: #60f0f0; }
.highlight.opt { color: #ffffff; }
.highlight.kwa { color: #ffffff; font-weight: bold; }
.highlight.kwb { color: #f0a0a0; }
.highlight.kwd { color: #a0f0a0; }
</style>
</head>

<body>
<div id="body">
<div id="logo">
<a href="./"><img src="puzzle-dungeon-logo.jpg" alt="Ⓟⓤⓩⓩⓛⓔ Ⓓⓤⓝⓖⓔⓞⓝ"></a>
</div>
<div id="sidebar">
<a href="./"><button class="page">About</button></a>
<a href="news.html"><button class="page">News</button></a>
<a href="download.html"><button class="page">Download</button></a>
<a href="dungeon.html"><button class="page">dungeon <i>(tool)</i></button></a>
<a href="sokodun.html"><button class="page">sokodun <i>(tool)</i></button></a>
<a href="sokobansolver.html"><button class="page current-page">Sokoban Solver</button></a>
<a href="resources.html"><button class="page">Resources</button></a>
<a href="authors.html"><button class="page">Authors</button></a>
<hr>
<a href="puzzles/"><button class="page">Puzzles</button></a>
<a href="videos/"><button class="page">Videos</button></a>
<a href="screenshots/"><button class="page">Screenshots</button></a>
<a href="themes/"><button class="page">Themes</button></a>
<a href="tutorials/"><button class="page">Tutorials</button></a>

</div>
<div id="header">
<div id="categories">
<a href="./"><button class="category current-category">Home</button></a>
<a href="./puzzles/"><button class="category">Puzzles</button></a>
<a href="./videos/"><button class="category">Videos</button></a>
<a href="./screenshots/"><button class="category">Screenshots</button></a>
<a href="./themes/"><button class="category">Themes</button></a>
<a href="./tutorials/"><button class="category">Tutorials</button></a>
</div>
</div>
<div id="content">
<h1 id="sokoban-solver-in-puzzle-dungeon">Sokoban Solver in Puzzle
Dungeon</h1>
<h2 id="overview">Overview</h2>
<p>Puzzle Dungeon includes a full-featured Sokoban solver that is
tightly integrated with both the graphical game <a
href="dungeon.html">dungeon</a> and the command-line tool <a
href="sokodun.html">sokodun</a>.</p>
<p>The code is Free Software, and should run on GNU/Linux, Windows,
MacOS.</p>
<p>The solver is implemented entirely in Python, follows classical
search theory, and its correctness and optimality are validated by
comprehensive automated tests.</p>
<p>It works well for small maps, and in some cases medium-sized maps. It
prioritizes correctness, flexibility, and clarity over raw performance,
although a considerable number of domain-specific and python-specific
optimizations are present.</p>
<h2 id="supported-search-algorithms">Supported Search Algorithms</h2>
<p>The solver supports multiple classical graph search algorithms,
selectable at runtime:</p>
<ul>
<li><p><strong>Breadth-First Search (BFS)</strong><br />
Explores all positions by increasing depth (number of pushes).</p></li>
<li><p><strong>Uniform Cost Search (UCS)</strong><br />
Explores positions in order of increasing total cost for the selected
metric, without using heuristics. The first solution found is
optimal.</p></li>
<li><p><strong>A*</strong><br />
Uses admissible heuristics (cost so far plus a lower-bound estimate of
remaining cost) to guide the search and find optimal solutions.</p></li>
<li><p><strong>Greedy Best-First Search</strong><br />
Uses the same heuristics as A* but prioritizes estimated remaining cost.
Optimality is not guaranteed, but solutions are often found
faster.</p></li>
<li><p><strong>Depth-First Search (DFS)</strong><br />
Non-optimal and primarily useful for experimentation and debugging. May
use less memory, but has its own artifacts. It is implemented as IDDFS
with a depth step.</p></li>
</ul>
<p>The optimality of BFS, UCS, and A* is confirmed by comprehensive
tests across different level classes.</p>
<h2 id="solution-types-and-cost-metrics">Solution Types and Cost
Metrics</h2>
<p>The solver supports two solution types:</p>
<ul>
<li><p><strong>Move-optimal solutions</strong><br />
Minimize the number of character moves, with shifts (pushes or pulls) as
a secondary metric.</p></li>
<li><p><strong>Push-optimal solutions</strong><br />
Minimize the number of shifts (pushes or pulls), with moves as a
secondary metric.</p></li>
</ul>
<p>All costs are represented uniformly as a <strong>lexicographic
pair</strong> <em>(num_moves, num_shifts)</em>. This representation is
used consistently for path costs, lower-bound estimates, and solution
costs.</p>
<h2 id="solver-architecture">Solver Architecture</h2>
<p>The <strong>Position</strong> (search node) represents a unique
combination of the character location and all barrel locations.</p>
<p>Barrel locations are stored in a <strong>SuperPosition</strong>
object. A Position is one character placement within its super-position.
This allows multiple character states to share properties of the same
barrel configuration, such as:</p>
<ul>
<li>solved / dead status,</li>
<li>lower-bound path cost and solution estimation,</li>
<li>precomputed matching data.</li>
</ul>
<p>Other properties are stored per Position, including:</p>
<ul>
<li>parent pointer,</li>
<li>edge-specific cost (own_nums),</li>
<li>accumulated path cost (total_nums),</li>
<li>child edge information (when needed for edge relaxation).</li>
</ul>
<p>Each position has a single best parent at any time. If a better path
to an existing position is found, the position is reparented. For
algorithms that require edge relaxation (A*, BFS by moves), potential
child edges are stored to allow reparenting back when accumulated path
cost improves.</p>
<h2 id="heuristics-and-lower-bounds">Heuristics and Lower Bounds</h2>
<p>All search algorithms benefit from prepared domain-specific data:</p>
<ul>
<li><p><strong>Dead cells</strong><br />
Cells where a barrel can never participate in a solution are detected
upfront and excluded.</p></li>
<li><p><strong>Precomputed costs</strong></p>
<ul>
<li>Lower-bound costs from every non-dead cell to every goal cell.</li>
<li>Lower-bound costs from any initial barrel cell to all reachable
cells.</li>
</ul></li>
<li><p><strong>Perfect matching of barrels to plates</strong><br />
A lower bound for assigning barrels to goal cells is computed using the
<strong>Hungarian algorithm</strong>.</p></li>
</ul>
<p>The lower bound from a position to a solution uses perfect matching.
The lower bound from the initial position to intermediate positions
(currently used for pruning after a solution is found) is computed as a
sum of minimal barrel-to-target costs without matching.</p>
<p>For heuristic-based algorithms (A* and Greedy), the perfect matching
is used. The admissible heuristics preserves optimality for A*.</p>
<p>For UCS, optimality follows directly from cost-order exploration: the
first solution found is optimal.</p>
<p>For BFS:</p>
<ul>
<li>By shifts: optimality follows from fixed-depth exploration.</li>
<li>By moves: optimality is ensured via sorting and edge
relaxation.</li>
</ul>
<p>Prepared data can be disabled for experimentation or
benchmarking.</p>
<h2 id="special-level-support">Special Level Support</h2>
<p>The solver supports several special Sokoban level classes:</p>
<ul>
<li><p><strong>Circular levels</strong><br />
Levels where the initial position is already solved (all barrels start
on plates). A solution must include at least one shift (push or pull),
making these levels non-trivial.</p></li>
<li><p><strong>Zero-Space Type-B (ZSB) levels</strong><br />
Only a restricted but valid subset of moves is generated, resulting in
significantly faster solving. See the forum discussion about <a
href="https://groups.io/g/sokoban/topic/113333167">Zero-Space
Type-B</a>.</p></li>
<li><p><strong>Reverse Barrel Mode</strong><br />
Storage cells are replaced with barrels, and the player pulls instead of
pushing. Shifts become pulls at the grid level; the solver logic itself
remains unchanged. The character position is currently unchanged, which
makes some puzzles unsolvable in this mode. The proper fix is to change
the initial character location according to the solution in forward
(push) mode, if known.</p></li>
</ul>
<h2 id="deadlock-detection">Deadlock Detection</h2>
<p>The following types of deadlocks are detected:</p>
<ul>
<li>simple local deadlocks (for example, 2x2 patterns),</li>
<li>dynamic match deadlocks (barrel-to-plate assignment via
Hungarian),</li>
<li>freeze deadlocks (barrels form zigzag between walls, block each
other),</li>
<li>corral freeze deadlock (corrals with no valid barrel pushes to
open).</li>
</ul>
<h2 id="solver-design-highlights">Solver Design Highlights</h2>
<ul>
<li>Support for a wide range of Sokoban level variants.</li>
<li>Support for move-optimal and push-optimal solutions.</li>
<li>Support for forward and reverse modes.</li>
<li>Detection of multiple local and dynamic deadlock types.</li>
<li>Explicit state graph with reopening support.</li>
<li>Correct edge relaxation and state reparenting.</li>
<li>Clear separation between algorithm, cost model, and heuristics.</li>
<li>Unified solver core for GUI and CLI.</li>
<li>Extensive regression tests.</li>
<li>Optional return-first mode, trading optimality for speed.</li>
</ul>
<h2 id="incremental-solving-and-budgeting">Incremental Solving and
Budgeting</h2>
<p>The solver implements a cooperative budget protocol:</p>
<ul>
<li>Control is yielded approximately once per second.</li>
<li>Progress messages are emitted.</li>
<li>Solving can resume from the interruption point.</li>
</ul>
<p>This report-progress behavior is used by both the GUI and the
command-line tool and can be disabled.</p>
<h2 id="special-debug-flags">Special Debug Flags</h2>
<p>Both the graphical game <a href="dungeon.html">dungeon</a> and the
command-line tool <a href="sokodun.html">sokodun</a> support the
following <em>-d FEATURE</em> (or <em>–debug FEATURE</em>) flags:</p>
<ul>
<li><em><code>prun</code></em> - report prune, deadlock and solution
counters every second</li>
<li><em><code>nofd</code></em> - disable detection of Freeze
deadlocks</li>
<li><em><code>nocd</code></em> - disable detection of Corral Freeze
deadlocks</li>
<li><em><code>dlck</code></em> - display all Match, Freeze and Corral
Freeze deadlocks</li>
<li><em><code>sevt</code></em> - dump SokobanSolver event log (floody;
redirect to *.sel file)</li>
<li><em><code>solv</code></em>, <em><code>solv+</code></em>,
<em><code>solv++</code></em> - dump position processing log
(floody)</li>
<li><em><code>prevalid</code></em> - dump prepared valid shift data per
level</li>
<li><em><code>precosts</code></em>, <em><code>precosts+</code></em> -
dump prepared costs data per level</li>
</ul>
<p>These feature flags are handled by SokobanSolver itself, either
changing behaviour or writing relevant output to stdout. Multiple flags
may be specified using separate -d options.</p>
<p>There is no way to disable detection of Match (or Bipartite)
deadlocks. By design, the costs and valid shifts do not make sense for
mismatched board positions (for which there is no perfect
barrel-to-plate matching). So such Position object is just never
created; this can’t be disabled.</p>
<h2 id="gui-vs-cli-keys-and-options">GUI vs CLI, Keys and Options</h2>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 16%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="header">
<th>GUI key</th>
<th>CLI option</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>RCtrl-1</td>
<td><code>-1</code></td>
<td>Toggle return-first solution mode</td>
</tr>
<tr class="even">
<td>RCtrl-A</td>
<td><code>-A</code></td>
<td>Use A* algorithm</td>
</tr>
<tr class="odd">
<td>RCtrl-B</td>
<td><code>-B</code></td>
<td>Use BFS algorithm</td>
</tr>
<tr class="even">
<td>RCtrl-D</td>
<td><code>-D</code></td>
<td>Use DFS algorithm</td>
</tr>
<tr class="odd">
<td>RCtrl-G</td>
<td><code>-G</code></td>
<td>Use Greedy algorithm</td>
</tr>
<tr class="even">
<td>RCtrl-U</td>
<td><code>-U</code></td>
<td>Use UCS (Uniform Cost) algorithm</td>
</tr>
<tr class="odd">
<td>RCtrl-0</td>
<td><code>-0</code></td>
<td>Disable periodic progress reporting</td>
</tr>
<tr class="even">
<td>RCtrl--</td>
<td><code>-_</code></td>
<td>Disable cost and valid shift preparation (debug only)</td>
</tr>
<tr class="odd">
<td>KP_Enter</td>
<td>default</td>
<td>Find a push optimal solution</td>
</tr>
<tr class="even">
<td>Shift-KP_Enter</td>
<td><code>-m</code></td>
<td>Find a move optimal solution</td>
</tr>
<tr class="odd">
<td>Backspace</td>
<td><em>Ctrl-C</em> or N/A</td>
<td>Stop solving or playing a solution, or unset the solution</td>
</tr>
<tr class="even">
<td>RCtrl-Tab</td>
<td>N/A</td>
<td>Show the most recently created position while solving</td>
</tr>
<tr class="odd">
<td>RCtrl-Backquote</td>
<td>N/A</td>
<td>Show the most recently detected deadlock while solving</td>
</tr>
<tr class="even">
<td>Alt-R</td>
<td>N/A</td>
<td>Reload level (guaranteed same map unlike plain <em>r</em>)</td>
</tr>
<tr class="odd">
<td>Alt-E</td>
<td>N/A</td>
<td>Reload level with toggled reverse-barrel mode</td>
</tr>
<tr class="even">
<td>Alt-C</td>
<td>N/A</td>
<td>Load custom collection levels from the clipboard</td>
</tr>
<tr class="odd">
<td>Alt-S</td>
<td>N/A</td>
<td>Load a solution from the clipboard</td>
</tr>
</tbody>
</table>
<p>In both GUI and CLI modes, levels may be loaded from the clipboard or
standard input using <code>clipboard:</code> or <code>stdin:</code> or
<code>-</code> arguments, and all detected deadlocks may be dumped to
standard output using <code>--debug dlck</code> option (this can be
pretty floody).</p>
<h2 id="performance-notes">Performance Notes</h2>
<p>This is possibly the most complete Sokoban solver implemented in
Python.</p>
<p>It may be much slower than some specialized solvers because:</p>
<ul>
<li>it is written in the high-level Python language,</li>
<li>advanced corral based heuristics are not yet implemented.</li>
</ul>
<p>A typical Sokoban level contains many millions of unique positions.
Currently the solver keeps all visited positions and never removes them
while solving. It would be much slower without this permanent cache.</p>
<p>There is no memory management yet. It will eventually fill all
available memory. The operating system may kill the process, but this
can freeze the computing unit. Therefore, remember to stop the process
(by pressing <em>Ctrl-C</em> in the CLI or any button like
<em>Space</em> in the GUI), or limit it by time (“-T 600” limits
execution to 10 minutes in the CLI). Garbage collection takes time, so
please be patient after using lots of memory.</p>
<p>You can run the solver on large levels to observe where it gets
stuck, but do not leave it running for too long. It is recomended to
always start with return-first Greedy mode (specify “sokodun -1” or
press <em>RCtrl-1</em> in the GUI). Once it finds a return-first
solution in reasonable time, you may attempt to solve it using BFS, A*
or USC (<em>-B</em>, <em>-A</em>, <em>-U</em> with optional <em>-m</em>
in the CLI, or <em>RCtrl-{B,A,U}</em> followed by <em>KP_Enter</em> or
<em>Shift-KP_Enter</em> in the GUI) to find a push-optimal or
move-optimal solution.</p>
<p>If the solution does not progress quickly for Greedy or A<em>, this
can mean some non-trivial deadlock was not detected, and expanding a
deadlocked position is costy. Press </em>RCtrl-Backquote* in the GUI to
see the last discovered dynamic deadlock. Press <em>RCtrl-Tab</em> (any
number of times) to see the last created position; if it contains an
undetected deadlock, this can explain long processing times.</p>
<p>Despite performance limitations, this Sokoban solver is well suited
for Puzzle Dungeon gameplay, testing, and provides a solid foundation
for tooling, research, and further optimization.</p>
<h2 id="validity-of-solutions">Validity of Solutions</h2>
<p>There are comprehensive tests. If you discover any anomaly, like a
non-optimal solution for a letslogic level using BFS or A*, or a
“Solution not found” result, please report such exotic cases. They can
then be fixed, added to tests, and prevented from recurring.</p>
<p>If the minimal solution depth (number of pushes) is determined to be
larger than 500, the solution is currently reported immediately as “not
found”. This limitation may be removed in the future.</p>
<p>Enjoy!</p>

</div>
</div>
</body>
</html>
